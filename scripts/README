# Steps for reproducing the result

We list all the steps to reproduce the results. In side each step, the scripts can run in parallel to speedup the process, while steps should be run in order.

## Build simulators
### Build scarab
```
bash 1-simulators/run.sh
```
### Build mcPat
```
bash 3-power-model/run.sh
```

## Genearte Traces for FURBYS and FLACK
### Generate FLACK traces and FURBYS hints
```
bash 2-prepare-traces/run.sh
```

### Generate cross-validation FLACK and FURBYS traces
```
bash 10-prepare-cross-traces/run.sh
```

## Genearte Traces for Baselines
### Generate Belady traces
```
bash 5-prepare-belady-traces/run.sh
```

## Experiments

### Experiment 1: perfect structures (Figure)
We compare the performance per-watt (PPW) of assume different micro-architectures are perfect.
```
bash 4-perfect-arch/run.sh
```

### Experiment 2: FURBYS miss reduction, PPW gain (Figure)
This experiment shows the main results of the paper. We compare the performance per-watt (PPW) of FLACK and FURBYS against existing techniques.
```
bash 6-furbys-main-evaluation/run.sh
```

### Experiment 3: FLACK ablation study (Figure)
This experiment shows the ablation study of FLACK. We incorporate different components of FLACK to see their impact on the performance.

```
bash 7-flack-ablation/run.sh
```

### Experiment 4: FURBYS cross-validation (Figure)
We derive FURBYS hints using a set of traces and use the trace to evaluate the performance of FURBYS on the rest of the traces to demonstrate the generalization of FURBYS.
```
bash 11-cross-validation/run.sh
```

### Experiment 5: FURBYS with different input traces (Figure)
We evaluate the performance of FURBYS with different input traces to show the different of traces generated by FLACK and other baselines.

```
bash 9-furbys-different-traces/run.sh
```

### Experiment 6: ISO-IPC test
We compare the miss reduction and IPC speedup of FURBYS against LRU with various cache sizes. 
```
bash 8-iso-ipc/run.sh
```